\part{The Graph Abstract Data Type}
\label{ch:graphadt}


\chapter{Graph definitions} %-------------------------------------------------
\label{sec:graphdefs}

Graphs are important and general mathematical objects that are widely used in theory and practice. 

Graphs distill the basic idea of a relationship among a set of objects. 

Informally we can think of a graph as a collection of dots (the set of objects) with lines connecting them (describing the relationship). 
The lines can be either directed (arrows) or undirected.

% \begin{Example}\label{ex:graphExample}
% A graph $G_1$ and a directed graph (digraph) $G_2$.
% \begin{center}
% \includegraphics{graphEx}
% \end{center}
% \end{Example}

We are interested in the algorithmic aspects of graph theory (``how can we do it efficiently and systematically?").  
To talk about this precisely, we must start with precise definitions.

We start with the concept a \textbf{di}rected \textbf{graph}, or digraph. 

\begin{Definition}\label{def:digraph} 
A \defnfont{digraph} $G=(V,E)$ is a  finite nonempty set $V$ of \defnfont{nodes} 
together with a (possibly empty) set $E$ of ordered pairs of nodes of $G$ called \defnfont{arcs}. 
Digraph stands for \textbf{di}rected \textbf{graph}.
\end{Definition}

\begin{Boxample}[0] \label{ex:digraph}
For the digraph shown below, write down the sets $V$ and $E$.\\
\newline 
\includegraphics{graphExDirectedVE}
\end{Boxample}


\begin{Definition}\label{def:graph}
A \defnfont{graph} $G = (V, E)$ is a finite nonempty  set $V$ of 
\defnfont{vertices} together with a (possibly empty) set $E$ of unordered
pairs of vertices of $G$ called \defnfont{edges}. 
Note that the singular of vertices is \defnfont{vertex}.
\end{Definition}

\begin{Boxample}[0] \label{ex:graph}
For the graph shown below, write down the sets $V$ and $E$.\\
\newline 
\includegraphics{graphExUndirectedVE}
\end{Boxample}


% \begin{figure}
%   \centering
%   \includegraphics{graphEx}
%   \caption{A graph $G_1$ and a digraph $G_2$.}
%   \label{fig:graphExample}
% \end{figure}


\begin{note}
Graphs vs Digraphs
\begin{itemize}
  \item In order to save writing ``(di)graph" too many times, we treat the digraph as the fundamental concept.
  \item When we say something about digraphs, nodes and arcs, it is understood to also hold for graphs, nodes and edges unless explicitly stated otherwise. 
  \item However, if we talk about graphs, edges, and vertices, our statement is not necessarily true for digraphs. 
  \item Some authors use ``undirected graph'' to mean graph and use the term ``graph" to mean what we call a directed graph. We always use digraph and graph.
  \item $E$ is a set so there are no multiple arcs between a pair of nodes.
 \item  An arc that begins and ends at the same node is called a \defnfont{loop}. 
  We make the convention that \boldfont{loops are not allowed in our digraphs}. 
  \item For digraph $G$ we may denote the node set $V(G)$
  and arc set $E(G)$ for clarity.
  \item A graph can be viewed as a digraph where every unordered edge $\{u, v\}$ 
  is replaced by two directed arcs $(u, v)$ and $(v, u)$.  
  This works in most instances and has the advantage of allowing us to consider only digraphs.
%  \item Sometimes we must know whether our object is really a graph or just a symmetric digraph. Whenever there
%  is a potential ambiguity, we shall point it out.
 \end{itemize}
\end{note}


\begin{Definition}\label{def:adjacent}  
If $(u, v)\in E$ (that is, if there is an arc going from $u$ to $v$) we say that $v$ is \defnfont{adjacent} 
to $u$, that $v$ is an \defnfont{out-neighbour} of $u$, and that $u$ is an \defnfont{in-neighbour} of $v$.
In an (undirected) graph $G$, if $\{u, v\} \in E$, then $u$ is a \defnfont{neighbour} of $v$ and $v$ is a neighbour of $u$. 
\end{Definition}

\begin{Boxample}[2]
% In the digraph $G_2$ in \cref{fig:graphExample}, find all in-neighbours of node 2.
In the digraph in \cref{ex:digraph}, find all in-neighbours of node 2.
\end{Boxample}


%\begin{Example}
%Every rooted tree (see Section~\ref{sec:app:trees}) 
%can be interpreted as a digraph: there is an arc from
%each node to each of its children. \index{rooted tree} 
%
%\end{Example}


\begin{Definition} 
The \defnfont{order} of a digraph $G = (V, E)$ is $\abs{V}$, the number of nodes. 
The \defnfont{size} of $G$ is $\abs{E}$, the number of arcs. 
We usually use $n$ to denote $\abs{V}$ and $m$ to denote $\abs{E}$.
\end{Definition}
 

For a given order $n$, the size $m$ can be as low as $0$ (a digraph consisting of $n$ nodes and no arcs)  
and as high as $n(n-1)$ (each node can point to each other node; recall that we do not allow loops).

\begin{Definition}  
If $m$ is toward the low end, the digraph is called \defnfont{sparse}, 
and if $m$ is toward the high end, then the digraph is called \defnfont{dense}. 
These terms are obviously very informal. 
For our purposes we will call a class of digraphs sparse if $m$ is $O(n)$ and dense if $m$ is $\Omega(n^2)$.
\end{Definition}


\begin{Definition} 
A \defnfont{walk} in a digraph $G$ is a sequence of nodes $v_0\, v_1\, \ldots\, v_l$ 
such that, for each $i$ with $0 \leq i < l$, $(v_i, v_{i+1})$ is an arc in $G$. 

The \defnfont{length} of the walk $v_0\, v_1\, \ldots \,v_l$ is the number $l$ (that is, the number of arcs involved).

A \defnfont{path} is a walk in which no node is repeated. 

A \defnfont{cycle} is a walk in which $v_0 = v_l$ and no other nodes
are repeated.
\end{Definition}

In a graph, a walk of the form $u\, v\, u$ --- going back and forth along the same edge --- is not considered a cycle.  A cycle in a graph must be of length at least $3$.


\begin{Boxample}
For the graph on the left the following
sequences of vertices are classified as being walks, paths, or cycles. Complete the table.

\begin{minipage}[c]{0.3\textwidth}
\centering
\includegraphics{graphExUndirected}
\end{minipage}
\begin{minipage}[c]{0.65\textwidth}
\begin{tabular}{|l|c|c|c|}\hline
\textbf{vertex sequence} & \textbf{walk?} & \textbf{path?} & \textbf{cycle?} \\ \hline
$0\, 3\, 2$                  & no  & no  &   \\
$0\, 1\, 2\, 3\, 4$          &  & yes & no  \\
$0\, 1\,  2\,  0$            & yes & no  & yes  \\
$0 \, 1\,  0$                & yes & no  &  \\
$1\,  2\,  3\,  4\,  2\,  0$ &     &     &  \\
\hline
\end{tabular}
\end{minipage}
\end{Boxample}

\begin{Boxample}[8]
Show that if there is a walk from $u$ to $v$, then we can find a path from $u$ to $v$.
\end{Boxample}


\begin{Definition} 
In a graph, the \defnfont{degree} of a vertex $v$ is the number of edges meeting $v$. 

In a digraph, the \defnfont{outdegree} of a node $v$ is the number of out-neighbours of $v$, 
and the \defnfont{indegree} of $v$ is the number of in-neighbours of $v$.

A node of indegree $0$ is called a \defnfont{source} and a node of outdegree $0$ is called a \defnfont{sink}.
\end{Definition}


\begin{Definition}
The \defnfont{distance} from $u$ to $v$ in $G$, denoted by $d(u,v)$, is 
the number of arc on the shortest path from $u$ to $v$. If no path exists, the 
distance is undefined (or $+\infty$).
\end{Definition}

For graphs, we have $d(u,v) = d(v,u)$ for all vertices $u, v$. 

\begin{Boxample}[2]
jo TODO: make this a do it yourself example \\
In the graph of \cref{ex:graph}, we can see by considering
all possibilities that $d(0, 1) = 1$, $d(0, 2) = 1$, $d(0, 3) = 2$,
$d(0, 4) = 2$, $d(1, 2) = 1$, $d(1, 3) = 2$, $d(1, 4) = 2$, $d(2, 3) =
1$, $d(2, 4) = 1$ and $d(3, 4) = 1$.

In the digraph of \cref{ex:digraph}, we have, for example, $d(0, 2) = 1, d(3, 2) = 2$. 
Since node $2$ is a sink, $d(2, v)$ is not defined unless $v = 2$, in which case the value is $0$.
\end{Boxample}



\section{Creating new digraphs from old ones}

There are several ways to create new digraphs from old ones.

One way is to delete nodes and arcs in such a way that the 
resulting object is still a digraph (no arcs missing
endpoints).

\begin{Definition}
A \defnfont{subdigraph} of a digraph $G = (V, E)$ is a digraph $G' = (V', E')$ 
where $V'\subseteq V$ and $E'\subseteq E$. 
A \defnfont{spanning} subdigraph is one with $V' = V$; that is, it contains all nodes.
\end{Definition}

\begin{Example}
%\Cref{fig:sub+span} shows (on the left) a subdigraph and (on the right) a spanning subdigraph of the digraph $G_2$ of \cref{fig:graphExample}.
A digraph (on the left) with a subdigraph (in the middle) and a spanning subdigraph (on the right).
\begin{center}
\includegraphics{graphExSubSpan} 
\end{center}
\end{Example}
% \begin{figure}[h]
% \centering
% \includegraphics{graphExSubSpan} 
% \caption{A subdigraph and a spanning subdigraph of $G_2$.}
% \label{fig:sub+span}
% \end{figure}

\begin{Definition}
The subdigraph \defnfont{induced} by a subset $V'$ of $V$ is the digraph
$G' = (V', E')$ where $E' = \set{(u, v) \in E \mid u \in V' \mbox{ and } v\in V'}$.
\end{Definition}

\begin{Boxample}
% \Cref{fig:induced} shows the subdigraph of the  digraph $G_2$ of \cref{fig:graphExample} induced by  \set{1, 2, 3}.
jo TODO: change figure by removing arrows \\
For the digraph shown on the left, draw the subdigraph induced by  \set{1, 2, 3} on the right.
\begin{center}
\includegraphics{graphExInduced}
\end{center}
\end{Boxample}

% \begin{figure}[h]
% \centering
% \includegraphics{graphExInduced}
% \caption{The subdigraph of $G_2$ induced by \set{1, 2, 3}.}
% \label{fig:induced}
% \end{figure}

%It is sometimes useful to ``reverse all the arrows''. This produces the ``reverse digraph''.

\begin{Definition}
The \defnfont{reverse digraph} of the digraph $G = (V, E)$, is the digraph $G_r = (V, E')$ where $(u, v)\in E'$ if and only if $(v, u)\in E$.
\end{Definition}

\begin{samepage}
\begin{Example}
% \Cref{fig:reverse} shows the reverse of the digraph $G_2$ of \cref{fig:graphExample}.
Digraph $G$ and its reverse $G_r$. We simply reverse all the arrows.
\begin{center}
\includegraphics{graphExReverse}
\end{center}
\end{Example}
\end{samepage}
% \begin{figure}[h]
% \centering
% \includegraphics{graphExReverse}
% \caption{The reverse of digraph $G_2$.}
% \label{fig:reverse}
% \end{figure}

It is sometimes useful to ignore the direction of arcs in a digraph to find the associated `underlying graph''.

\begin{Definition}
The \defnfont{underlying graph} of a digraph $G = (V, E)$ is the graph 
$G' = (V, E')$ where $E' = \set{\{u, v\} \mid (u, v)\in E}$.
\end{Definition}


Note: The underlying graph does not have multiple edges even when there are arcs $(u, v)$ and $(v, u)$. 
In that case, only one edge joins $u$ and $v$ in the underlying graph $G'$.  
%This is because $\{u, v\}$ and $\{v, u\}$ are equal as sets, so appear only once in the set $E'$.

\begin{Example}
%\Cref{fig:underly} shows the underlying graph of the digraph $G_2$ of \cref{fig:graphExample}.
A digraph $G$ and its underlying graph $G'$.
Note that there is only a single edge between vertices 1 and 3.
\begin{center}
\includegraphics{graphExUnderlying}
\end{center}
\end{Example}
% \begin{figure}
% \centering
% \includegraphics{graphExUnderlying}
% \caption{The underlying graph of $G_2$. Note that there is only a single edge between vertices 1 and 3.}
% \label{fig:underly}
% \end{figure}

\begin{Definition} 
We can combine two or more digraphs $G_1, G_2$, \ldots $G_k$ into a
single graph where the vertices of each $G_i$ are completely disjoint from
each other and no arc goes between the different $G_i$. The constructed
graph $G$ is called the \defnfont{graph union}, where $V(G) = V(G_1) \cup
V(G_2) \cup \ldots \cup V(G_k)$ and $E(G) = E(G_1) \cup E(G_2) \cup \ldots
\cup E(G_k)$.
\end{Definition}




%\subsection*{Exercises}
%
%\begin{Exercise}
%\label{ex:degree}
%Prove that in a digraph, the sum of all outdegrees equals the sum of all 
%indegrees. What is the analogous statement for a graph? 
%\end{Exercise}
%
%\begin{Exercise}
%\label{ex:distbound}
%Let $G$ be a digraph of order $n$ and $u, v$ nodes of $G$. 
%Show that $d(u, v) \leq n - 1$ if there is a walk from $u$ to $v$.
%\end{Exercise}
%
%
%\begin{Exercise}
%\label{ex:sparse-deg}
%Prove that in a sparse digraph, the average indegree of a node is
%$O(1)$, while in a dense digraph, the average indegree of a node is
%$\Omega(n)$.
%\end{Exercise}




 

\chapter{Graph data structures} \label{sec:graph-reps} %----------------------

When representing a digraph in a computer, we assume
that it has nodes given in a fixed order with the
\boldfont{convention that the nodes are labelled $0, 1, \dots, n - 1$}.

\begin{Definition}
Let $G$ be a digraph of order $n$. The \defnfont{adjacency matrix} of $G$
is the $n\times n$ Boolean matrix (often encoded with $0$'s and $1$'s)
such that entry $(i, j)$ is true if and only if there is an arc from the
node $i$ to node $j$.
\end{Definition}

\begin{Definition}
For a digraph $G$ of order $n$, an \defnfont{adjacency lists}
representation is a sequence of $n$ sequences, $L_0, \dots, L_{n-1}$. 
Sequence $L_i$ contains all nodes of $G$ that are out-neighbours of node $i$.
\end{Definition}

%In the adjacency lists representation, only the out-neighbours of node $i$ are listed in the sequence $L_i$. 
In the adjacency lists representation, $L_i$ may or may not be sorted in order of increasing node number. 
Our \boldfont{convention is to sort them whenever convenient}. 
Many implementations do \emph{not} enforce this convention.

\begin{Boxample}
A graph and its adjacency matrix and adjacency list.\\
\begin{center}
\begin{minipage}[c]{0.3\textwidth}
\centering
\includegraphics{graphExUndirected}
\end{minipage}
\begin{minipage}[c]{0.65\textwidth}
$\quad \left[
	\begin{matrix}
	0 & 1 & 1 & 0 & 0 \\
	1 & 0 & 1 & 0 & 0 \\
	1 & 1 & 0 & 1 & 1 \\
	0 & 0 & 1 & 0 & 1 \\
	0 & 0 & 1 & 1 & 0 
	\end{matrix}
\right] 
\qquad \qquad
\lightgraybox{
	\begin{array}{c|cccc}
	0 & 1 & 2 &   &   \\
	1 & 0 & 2 &   &   \\
	2 & 0 & 1 & 3 & 4 \\
	3 & 2 & 4 &   &   \\
	4 & 2 & 3 &   &   \\
	\end{array}
}
$
\end{minipage}
\end{center}
Notice that the number of $1$'s in a row in the adjacency matrix is the out-degree of the corresponding node, 
while the number of $1$'s in a column is the indegree.
\end{Boxample}


\begin{Boxample}
A digraph and its adjacency matrix and adjacency list.\\
\begin{center}
\begin{minipage}[c]{0.3\textwidth}
\centering
\includegraphics{graphExDirected}
\end{minipage}
\begin{minipage}[c]{0.65\textwidth}
$\quad 
\left[
\begin{matrix}
0 & 0 & 1 & 0 & 0 \\
1 & 0 & 1 & 1 & 0 \\
0 & 0 & 0 & 0 & 0 \\
0 & 1 & 0 & 0 & 1 \\
0 & 0 & 1 & 0 & 0 
\end{matrix}
\right]
\qquad \qquad
\lightgraybox{
	\begin{array}{c|ccc}
	0 & 2  \\
	1 & 0 & 2 & 3  \\
	2  \\
	3 & 1 & 4  \\
	4 & 2 \\
	\end{array}
}
$
\end{minipage}
\end{center}
An empty sequence occurs in the adjacency list where a node has no out-neighbours (for example, sequence $2$). 
\end{Boxample}

Sometimes the node labels in adjacency lists are omitted.
$$
\lightgraybox{
	\begin{array}{ccc}
	2 &   &   \\
	0 & 2 & 3 \\
	  &   &   \\
	1 & 4 &   \\
	2 &   &   \\
	\end{array}
}
$$



\begin{Boxample}[2]
Here are two digraphs in the adjacency matrix format. Draw the corresponding digraphs.

\vspace{1.5cm}
$\left[
\begin{matrix}
0 & 0 & 0 & 0  \\
0 & 0 & 0 & 1  \\
1 & 1 & 0 & 0  \\
0 & 0 & 1 & 0  \\
\end{matrix}
\right]$

\vspace{2.5cm}
$\left[
\begin{matrix}
0 & 1 & 0 & 1 & 0 \\
1 & 0 & 0 & 0 & 1 \\
0 & 1 & 0 & 0 & 1 \\
1 & 0 & 1 & 0 & 0 \\
0 & 0 & 1 & 1 & 0 
\end{matrix}
\right]$
\end{Boxample}

\begin{Boxample}[0]
Here are two digraphs in the adjacency lists format.  Draw the corresponding digraphs.
\label{ex:adjlist}

\vspace{1cm}
$\lightgraybox{\begin{array}{c|c}
0 & 2  \\
1 & 0  \\
2 & 1 \\
\end{array}}$

\vspace{1.5cm}
$\lightgraybox{\begin{array}{c|ccc}
0 & 1 & 2  \\
1 & 3  \\
2  \\
3 & 0 & 1 & 2 \\
\end{array}}$
\end{Boxample}

\section{Representing multiple graphs in a single file}

We can store several digraphs one after the other  in a single file as follows: 
\begin{itemize}
\item we have a single line giving the order at the beginning of
each digraph.
\item If the order is $n$ then the next $n$ lines give the
adjacency matrix or adjacency lists representation of the digraph. Node labels are omitted.
\item The end of the file is marked with a line denoting a digraph of order
$0$.
\end{itemize}

\begin{Example} The two digraphs from \cref{ex:adjlist} could be put in a single file as 

 \begin{tabular}{lll}
 3 \\
2  \\
 0 \\
 1  \\
 4 \\
 1 & 2 \\
 3 \\
  \\
 0 & 1 & 2 \\
 0\\
 \end{tabular}
 \end{Example}


\section{Using other structures to represent graphs}

Other specialized digraph representations may be used take advantage of
special structure in a family of digraphs for improved storage or access time. For such specialized
purposes they may be better adjacency matrices or lists.

For example, trees can be stored more efficiently. In \cref{sec:heapsort} we saw how a complete binary tree can be
stored in an array. A general rooted tree of $n$ nodes can be stored in
an array $\pred$ of size $n$. The value $\pred[i]$ gives the parent of
node $i$. The root is a special case and can be given value $-1$
(representing a NULL pointer), for example, if we number nodes from $0$
to $n-1$ in the usual way. This of course is a form of adjacency lists
representation, where we use in-neighbours instead of out-neighbours.

\begin{Boxample}[4]
Draw the tree represented by the array $\pred = [-,0,0,1,2,2,2,3]$
\end{Boxample}
%We will sometimes need to represent $\infty$ when processing graphs. For
%example, it may be more convenient to define $d(u, v) = \infty$ than to
%say it is undefined. From a programming point of view, we can use any
%positive integer that can not be confused with any other that might
%legitimately arise. For example, the distance between 2 nodes in a
%digraph on $n$ nodes cannot be more than $n - 1$ (see
%Exercise~\ref{ex:distbound}). Thus in this case we may use $n$ to
%represent the fact that there is no path between a given pair of nodes.
%We shall return to this subject in Chapter~\ref{ch:weighted}.

%\subsection*{Exercises}
%
%\begin{Exercise}
%\label{ex:list2matrix}
%
%Write down the adjacency matrix of the digraph of order $7$ whose 
%adjacency lists representation is given below.
%\newline
%$$
%\AdjLists{
%\begin{tabular}{cccc}
%2 &  & \\
%0 & &\\
%0 & 1&\\
%4 & 5 & 6\\
%5 & &\\
%3 & 4 & 6 \\
%1 & 2 & \\
%\end{tabular}
%}
%$$
%
%\end{Exercise}
%
%\begin{Exercise}
%\label{ex:matrix2list}
%
%Consider the digraph $G$ of order $7$ whose adjacency matrix 
%representation is given below. 
%\newline
%$$
%\left[
%\begin{matrix}
%0 & 1 & 0 & 0 & 1 & 1 & 0 \\
%1 & 0 & 0 & 1 & 0 & 0 & 0 \\
%1 & 0 & 0 & 0 & 0 & 0 & 1 \\
%1 & 0 & 0 & 0 & 0 & 1 & 0 \\
%0 & 0 & 0 & 0 & 0 & 1 & 0 \\
%0 & 0 & 0 & 0 & 0 & 0 & 0 \\
%0 & 0 & 0 & 0 & 0 & 1 & 0 \\
%\end{matrix}
%\right]
%$$
%
%Write down the adjacency lists representation of $G$.
%
%\end{Exercise}
%
%\begin{Exercise}
%\label{ex:listreverse}
%
%Consider the digraph $G$ of order $7$ given by the following 
%adjacency lists representation.
%$$
%\AdjLists{
%\begin{tabular}{cccc}
%2 &  & \\
%0 & &\\
%0 & 1&\\   
%4 & 5 & 6\\
%5 & &\\
%3 & 4 & 6 \\
%1 & 2 & \\
%\end{tabular}
%}
%$$
%
%Write down the adjacency matrix representation of the reverse digraph
%$G_r$.
%
%\end{Exercise}
%
%\begin{Exercise}
%\label{ex:divisible}
%
%Consider the digraph $G$ whose nodes are the integers from $1$ to $12$
%inclusive and such that $(i, j)$ is an arc if and only if $i$ is a
%proper divisor of $j$ (that is, $i$ divides $j$ and $i\neq j$).
%
%Write down the adjacency matrix representation of $G$ and of $G_r$.
%\end{Exercise}
%
%\begin{Exercise} \label{ex:heaprep} 
%Write the adjacency lists
%and adjacency matrix representation for a complete binary tree
%with $7$ vertices, assuming they are ordered $1, \dots, 7$ as in
%Section~\ref{sec:heapsort}.
%\end{Exercise}
%

\section{Implementation of digraph ADT}
\label{sec:graphadtimpl}

%We discuss implementing basic operations on digraphs such as checking the existence of an arc or deleting a node.
%%and compare the performance of different data structures.

An adjacency matrix is simply a matrix which is an array of arrays. 

Adjacency lists are a list of lists. There are several ways in which a list can be implemented, for
example by an array,  or singly- or doubly-linked lists using pointers.  These have different properties, for example, accessing the middle element is $\Theta(1)$ for an array but $\Theta(n)$ for a linked list. 

Searching for a value that may or may not be in the list requires sequential search
and takes $\Theta(n)$ time in the worst case. 

We do not consider other  data structures (e.g. heaps) that can be used to represent lists. 

\section{Complexity of basic digraph operations}
The basic operations we consider are checking for the existence of an arc between two nodes, finding the outdegree of a node, 
finding the indegree of a nodes, adding an arc between two nodes, deleting an arc between two nodes, adding a node, and deleting a node. 

For the two data structures, consider the steps we need to carry out various basic operations and the cost of all steps. 

\begin{Boxample}[0]
Compare the matrix and lists data structures for checking whether arc $(i,j)$ exists.
 
Adjacency matrix representation: we need to check whether element $(i,j)$ is 1. This requires accessing
an array element twice, to first find the $i$th array then its $j$th element. Each array access is in $\Theta(1)$ so overall it is in $\Theta(1)$.

Adjacency lists representation: we need to search for $j$ in list $i$. The complexity then depends on the length of list $i$. 
List $i$ is length $d$ where $d$ is the outdegree of node $i$ so searching for $j$ is in $\Theta(d)$. 
But how large is $d$? Even when the graph is sparse, it could still be the case that $d$ is $O(n)$, though typically in a sparse graph $d$ is $O(1)$.  
In a dense graph $d$ is $O(n)$.
\end{Boxample}

\begin{Boxample}[0]
Compare the matrix and lists data structures for deleting a node.

Adjacency matrix representation: In the matrix case, we must delete a row and column, 
and move up some elements so there are no gaps in the matrix. 
In the worst case, we need to move all remaining elements in the matrix and since there are now $(n-1)$s rows and columns, it takes time $\Theta(n^2)$.

Adjacency lists representation: we must remove a list and also all references to the deleted node in other lists. 
This requires scanning each list for the offending entry and deleting it. 
We thus need to visit $n$ lists and the combined length of all remaining lists which is (in the worst case) $m$, requiring $\Theta(n+m)$ work in total.
\end{Boxample}

This following two tables  show the steps required (the first table) 
and the time required (the second table) for basic graph operations when using adjacency matrix or lists representations.  
Performance for the adjacency list representation is based on using doubly linked lists.

\begin{samepage}
\begin{center}
Steps required to perform basic digraph operations by data structure.

\begin{tabular}{|l|l|l|l|l|}
\hline

\textbf{Operation} & \textbf{Adjacency Matrix} & \textbf{Adjacency Lists} \\
\hline

arc $(i, j)$ exists? & is entry $(i,j)$ 0 or 1  & find $j$ in  list $i$ \\
\hline
outdegree  of $i$ & scan row, count $1$'s & size of  list  $i$\\
\hline
indegree of $i$ & scan column,  count $1$'s & for $j\neq i$, find $i$ in list $j$ \\
\hline
add arc $(i, j)$ & change entry $(i ,j)$ & insert $j$ in list $i$ \\
\hline
delete arc $(i, j)$ & change entry $(i ,j)$ & delete $j$ from list $i$ \\
\hline
add node & create new row and column & add new list at end\\
\hline
delete node $i$ & delete row/column $i$  & delete list $i$ \\
& shuffle other entries & for $j\neq i$, delete  $i$ from list $j$ \\ 
\hline
\end{tabular}
\end{center}
\end{samepage}

%\begin{table}
%\caption{Comparative worst-case performance of adjacency lists and matrices.}
%\label{table:list-vs-matrix}

\begin{samepage}
\begin{center}
Comparative worst-case performance of adjacency lists and matrices.

\begin{tabular}{|l|c|c|}
\hline

\textbf{Operation} 	& \textbf{matrix} & \textbf{lists} \\
\hline

arc $(i, j)$ exists? & $\Theta(1)$  & $\Theta(d)$ \\
\hline
outdegree  of $i$ 	& $\Theta(n)$ & $\Theta(1)$ \\
\hline
indegree of $i$ 	& $\Theta(n)$ &  $\Theta(n+m)$ \\
\hline
add arc $(i, j)$ 	& $\Theta(1)$ & $\Theta(1)$  \\
\hline
delete arc $(i, j)$ & $\Theta(1)$  & $\Theta(d)$  \\
\hline
add node 			& $\Theta(n)$ & $\Theta(1)$  \\
\hline
delete node $i$ 	& $\Theta(n^2)$  & $\Theta(n+m)$  \\
\hline
\end{tabular}
\end{center}
\end{samepage}

Notice that apparently similar problems like finding the outdegree and indegree have very different time complexity in the lists representation but not in the matrix representation. 

Finding outdegree with the lists representation merely requires accessing
the correct list (constant time) plus finding the size of  that list
(constant time). 

Finding indegree with the  lists representation requires
scanning all lists except one ($n-1$ of them), and looking at every arc in
them, ($m$ arcs in the worst case), so taking time $\Theta(n+m)$. 


If we wish to compute just one indegree, this might be acceptable, but if all indegrees are required,
this will be inefficient. It is better to compute the reverse digraph once
and then read off the outdegrees, this last step taking time $\Theta(n)$ 
(see \cref{exr:compute-reverse}).

%One way around all this work is to use in
%our definition of adjacency lists representation, instead of just the
%out-neighbours, a list of in-neighbours also. This may be useful in some
%contexts but in general requires more space than is needed.



\section{Space requirements}

%We also need to consider the space requirements for each implementation. 

The adjacency matrix
representation requires $\Theta(n^2)$ storage as we simply need a matrix of $n^2$
bits 

At first guess we might say adjacency lists require
$\Theta(n+m)$ storage, since we need $n$ lists and the combined length of all the lists is $m$.
But node numbers require more than one bit of storage each: the number $k$ uses about  $\Theta(\log k)$ bits. The average entry in a list is $\frac n 2$, so the total space requirement is more like $\Theta(n+m \log(n))$ 


\begin{Boxample}[2]
What is the storage requirement for a complete digraph on $n$ nodes, that is, a digraph where every possible arc
occurs?
\end{Boxample}

For small, sparse digraphs, lists use less space than a matrix, whereas for small
dense digraphs the space requirements are comparable. For large sparse
digraphs, a matrix can still be more efficient, but this happens rarely.

\begin{Boxample}[2]
Find a large sparse digraph where the matrix representation uses less space than the lists representation.
\end{Boxample}

The representation that is best will depend on the application and we cannot make general rules.  We will mostly use adjacency lists, which are
clearly superior for many common tasks and generally better for sparse digraphs.

%Any implementation of an abstract data type (for example as a Java class)
%must include objects and ``methods".  While most people would include
%methods for adding nodes, deleting arcs, and so on, it is not clear where
%to draw the line. In Appendix~\ref{app:javagraph}, one way of writing Java
%classes to deal with graphs is presented in detail. There are obviously a
%lot of different choices one can make. In particular 
%for our Java lists representation we use 
%\verb|ArrayList<ArrayList<Integer>>|. 

%\section*{Exercises}
%
%\begin{Exercise}\label{exr:compute-reverse}
%Show how to compute the (sorted) adjacency lists representation of the 
%reverse digraph of $G$ from the (sorted) adjacency lists representation of 
%$G$ itself. It should take time $\Theta(n+m)$.
%\end{Exercise}

